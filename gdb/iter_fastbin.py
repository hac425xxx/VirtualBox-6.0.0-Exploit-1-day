import gdb
import struct

def write_memory(address, buffer, length=0x10):
    return gdb.selected_inferior().write_memory(address, buffer, length)

def get_pid():
    return gdb.selected_inferior().pid

def read_memory(addr, length=0x10):
    return gdb.selected_inferior().read_memory(addr, length).tobytes()

def u32(x: bytes) -> int:
    """Unpack one dword respecting the current architecture endianness."""
    endian = '<'
    return struct.unpack(f"{endian}I", x)[0] if not s else struct.unpack(f"{endian:s}i", x)[0]

def u64(x: bytes) -> int:
    """Unpack one qword respecting the current architecture endianness."""
    endian = '<'
    return struct.unpack(f"{endian:s}q", x)[0]

def read_u64(addr: int) -> int:
    sz = 8
    mem = read_memory(addr, sz)
    unpack = u32 if sz == 4 else u64
    return unpack(mem)


fs_base = int(gdb.selected_frame().read_register("fs_base"))
thread_arena = read_u64(fs_base - 112)
tcache = read_u64(fs_base - 0x80)

print("fs_base: 0x{:x}, thread_arena: 0x{:x}, tcache: 0x{:x}".format(fs_base, thread_arena, tcache))


tcache_0x30_head = read_u64(tcache + 0x40 + 8)
chunk = tcache_0x30_head
while True:
    if chunk == 0:
        break
    print("[*] tcache chunk at 0x{:x}".format(chunk - 0x10))
    chunk = read_u64(chunk)


bins = thread_arena + 0x70
smallbin_0x30_addr = bins + 0x20
smallbin_0x30_head = read_u64(bins + 0x20)
print("bins: 0x{:x}, smallbin_0x30_addr: 0x{:x}, smallbin_0x30_head: 0x{:x}".format(bins, smallbin_0x30_addr, smallbin_0x30_head))

chunk = smallbin_0x30_head
while True:
    if chunk == smallbin_0x30_addr - 0x10:
        break
    print("[*] smallbin chunk at 0x{:x}".format(chunk))
    chunk = read_u64(chunk + 0x10)


fastbinsY = thread_arena + 0x10
fastbins_0x30_head = read_u64(fastbinsY + 8)
print("fastbinsY: 0x{:x}, fastbins_0x30_head: 0x{:x}".format(fastbinsY, fastbins_0x30_head))

chunk = fastbins_0x30_head
while True:
    if chunk == 0:
        break
    print("[*] fastbin chunk at 0x{:x}".format(chunk))
    chunk = read_u64(chunk + 0x10)



